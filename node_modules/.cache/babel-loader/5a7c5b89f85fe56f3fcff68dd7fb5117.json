{"ast":null,"code":"import { cloneElement } from \"react\";\nexport const PROB_INFECTION = 0.3;\nexport const PROB_INFECTION_DECAY = 0.9;\nexport const newWorld = width => {\n  return {\n    People: [...Array(width).keys()].map(x => [...Array(width).keys()].map(y => {\n      return makePerson({\n        initX: x,\n        initY: y\n      });\n    }))\n  };\n};\nexport const getNextStateOfWorld = (currentState, neighborAddresses) => {\n  // currentState is an object consisting of\n  // People: list of list of Persons, i.e. Persons[x][y] gives you the person at x,y\n  // \n  const width = currentState.People.length;\n  const People = currentState.People;\n  People.forEach(col => {\n    People[col].forEach(row => {\n      People[col][row].infected = People[col][row].calcInfected(getNeighborsForPerson(People[col][row], People, neighborAddresses), 1);\n    });\n  });\n  return {\n    People: People\n  };\n};\nexport const getNeighborsForPerson = (person, AllPeople, neighborAddresses) => {\n  return neighborAddresses[person.x][person.y].map(address => AllPeople[address[0]][address[1]]);\n};\nexport const getAllNeighbors = width => {\n  const l = width - 1; // last index\n\n  let neighborsByCoords = [...Array(width).keys()].map(x => [...Array(width).keys()].map(y => {\n    if (x < l && y < l && x > 0 && y > 0) return [[x - 1, y - 1], [x, y - 1], [x + 1, y - 1], [x - 1, y], [x + 1, y], [x - 1, y + 1], [x, y + 1], [x + 1, y + 1]];\n    if (x === 0 && y === 0) return [[1, 0], [1, 1], [0, 1]];\n    if (x === 0 && y === l) return [[0, l - 1], [1, l - 1], [1, l]];\n    if (x === l && y === 0) return [[l - 1, 0], [l - 1, 1], [l, 1]];\n    if (x === l && y === l) return [[l - 1, l - 1], [l - 1, l], [l, l - 1]];\n    if (x === 0) return [[x, y - 1], [x + 1, y - 1], [x + 1, y], [x, y + 1], [x + 1, y + 1]];\n    if (y === 0) return [[x - 1, y], [x + 1, y], [x - 1, y + 1], [x, y + 1], [x + 1, y + 1]];\n    if (x === l) return [[x - 1, y - 1], [x, y - 1], [x - 1, y], [x - 1, y + 1], [x, y + 1]];\n    if (y === l) return [[x - 1, y - 1], [x, y - 1], [x + 1, y - 1], [x - 1, y], [x + 1, y]];\n  }));\n  console.log(neighborsByCoords);\n};\nexport const makePerson = properties => {\n  const {\n    initName,\n    initX,\n    initY,\n    initHealth,\n    initInfected,\n    initImmune\n  } = properties;\n  const name = initName ? initName : \"John\"; // health indicates whether person is normal, showing mild symptons, severe symptoms, or dead\n\n  const health = initHealth ? initHealth : 0; // infected is a boolean indicating whether person is infected \n\n  const infected = !!initInfected ? true : false; // immune is a boolean indicating whether person is immune \n\n  const immune = !!initImmune ? true : false;\n  const x = initX ? initX : 0;\n  const y = initY ? initY : 0;\n  return {\n    name: name,\n    x: x,\n    y: y,\n    health: health,\n    infected: infected,\n    immunue: immune,\n    calcInfected: (neighbors, distancing) => {\n      // neighbors is an object with different tiers of neighbors lists 0 is closest, 1 is next closest, etc\n      // distancing is a constant >= 1\n      let probNotInfected = 1;\n      Object.keys(neighbors).forEach(neighborTier => {\n        const numNeighbors = neighbors[neighborTier].filter(neighbor => neighbor.infected).length;\n        probNotInfected = probNotInfected * Math.pow(1 - PROB_INFECTION * Math.pow(PROB_INFECTION_DECAY, neighborTier) / distancing, numNeighbors);\n      });\n      console.log(name + \"'s chance of getting infected = \" + (1 - probNotInfected));\n      return Math.random() < probNotInfected;\n    }\n  };\n};","map":{"version":3,"sources":["/Users/yan/Coding/flattenthecurve/src/Simulate.js"],"names":["cloneElement","PROB_INFECTION","PROB_INFECTION_DECAY","newWorld","width","People","Array","keys","map","x","y","makePerson","initX","initY","getNextStateOfWorld","currentState","neighborAddresses","length","forEach","col","row","infected","calcInfected","getNeighborsForPerson","person","AllPeople","address","getAllNeighbors","l","neighborsByCoords","console","log","properties","initName","initHealth","initInfected","initImmune","name","health","immune","immunue","neighbors","distancing","probNotInfected","Object","neighborTier","numNeighbors","filter","neighbor","Math","pow","random"],"mappings":"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","sourcesContent":["import { cloneElement } from \"react\";\n\nexport const PROB_INFECTION = 0.3\nexport const PROB_INFECTION_DECAY = 0.9\n\n\nexport const newWorld = (width) => {\n\treturn {\n\t\tPeople: [...Array(width).keys()].map(x =>\n\t\t\t\t[...Array(width).keys()].map(y => {\n\t\t\t\t\treturn makePerson({initX:x,initY:y})\n\t\t\t\t})\n\t\t\t)\n\t}\n}\n\nexport const getNextStateOfWorld = (currentState,neighborAddresses) => {\n\t// currentState is an object consisting of\n\t// People: list of list of Persons, i.e. Persons[x][y] gives you the person at x,y\n\t// \n\n\tconst width = currentState.People.length;\n\tconst People = currentState.People;\n\n\tPeople.forEach(col => {\n\t\tPeople[col].forEach(row => {\n\t\t\tPeople[col][row].infected = People[col][row].calcInfected(\n\t\t\t\t\tgetNeighborsForPerson(People[col][row],People,neighborAddresses),\n\t\t\t\t\t1\n\t\t\t\t)\n\t\t})\n\t})\n\n\treturn {People:People}\n}\n\nexport const getNeighborsForPerson = (person,AllPeople,neighborAddresses) => {\n\treturn neighborAddresses[person.x][person.y].map(address => AllPeople[address[0]][address[1]]);\n}\n\nexport const getAllNeighbors = (width) => {\n\tconst l = width-1; // last index\n\tlet neighborsByCoords = [...Array(width).keys()].map(x =>\n\t\t[...Array(width).keys()].map(y => {\n\t\t\tif (x < l && y < l && x > 0 && y > 0 ) return [[x-1,y-1],[x,y-1],[x+1,y-1],[x-1,y],[x+1,y],[x-1,y+1],[x,y+1],[x+1,y+1]];\n\t\t\tif (x === 0 && y === 0) return [[1,0],[1,1],[0,1]];  \n\t\t\tif (x === 0 && y === l) return [[0,l-1],[1,l-1],[1,l]];  \n\t\t\tif (x === l && y === 0) return [[l-1,0],[l-1,1],[l,1]];  \n\t\t\tif (x === l && y === l) return [[l-1,l-1],[l-1,l],[l,l-1]];  \n\t\t\tif (x === 0) return [[x,y-1],[x+1,y-1],[x+1,y],[x,y+1],[x+1,y+1]];\n\t\t\tif (y === 0) return [[x-1,y],[x+1,y],[x-1,y+1],[x,y+1],[x+1,y+1]];\n\t\t\tif (x === l) return [[x-1,y-1],[x,y-1],[x-1,y],[x-1,y+1],[x,y+1]];\n\t\t\tif (y === l) return [[x-1,y-1],[x,y-1],[x+1,y-1],[x-1,y],[x+1,y]];\n\t\t})\n\t)\n\tconsole.log(neighborsByCoords);\n}\n\nexport const makePerson = (properties) => {\n\tconst {initName,initX,initY,initHealth,initInfected,initImmune} = properties;\n\tconst name = initName ? initName : \"John\";\n\t\n\t// health indicates whether person is normal, showing mild symptons, severe symptoms, or dead\n\tconst health = initHealth? initHealth : 0;\n\t\n\t// infected is a boolean indicating whether person is infected \n\tconst infected = !!initInfected ? true : false;\n\t\n\t// immune is a boolean indicating whether person is immune \n\tconst immune = !!initImmune ? true : false;\n\n\tconst x = initX ? initX : 0;\n\tconst y = initY ? initY : 0;\n\n\treturn {\n\t\tname: name,\n\t\tx: x,\n\t\ty: y,\n\t\thealth: health,\n\t\tinfected: infected,\n\t\timmunue: immune,\n\t\tcalcInfected: (neighbors,distancing) => {\n\t\t\t// neighbors is an object with different tiers of neighbors lists 0 is closest, 1 is next closest, etc\n\t\t\t// distancing is a constant >= 1\n\n\t\t\tlet probNotInfected = 1;\n\t\t\tObject.keys(neighbors).forEach(neighborTier => {\n\t\t\t\tconst numNeighbors = neighbors[neighborTier].filter(neighbor => neighbor.infected).length;\n\t\t\t\tprobNotInfected = probNotInfected \n\t\t\t\t\t* Math.pow( 1- (PROB_INFECTION * Math.pow(PROB_INFECTION_DECAY,neighborTier) / distancing) , numNeighbors )\n\t\t\t})\n\n\t\t\tconsole.log(name + \"'s chance of getting infected = \" + (1-probNotInfected));\n\n\t\t\treturn Math.random() < probNotInfected;\n\t\t}\n\t}\n}"]},"metadata":{},"sourceType":"module"}